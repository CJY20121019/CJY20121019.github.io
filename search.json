[{"title":"DeepSeek 本地部署指南","url":"/2026/02/16/DeepSeek 本地部署指南/","content":"**原文：<https://www.luogu.com.cn/article/i1kejuse> 点个赞吧！**\n\n---\n## 前言\n话说最近 DeepSeek 太火了，而且受到了攻击，所以[官网](https://www.deepseek.com/)卡得要命！\n\n所以我们可以在本地部署和运行 DeepSeek，实现 AI 对话的功能。\n## 安装\n在 [ollama 官网](https://ollama.com/) 上下载自己系统的版本。\n\n下载完后，重回 [ollama 官网](https://ollama.com/)，搜索 `deepseek-r1`，点第一个，然后选择适合自己电脑配置的选项，这里推荐 `7b` 的。\n![](https://cdn.luogu.com.cn/upload/image_hosting/c0t9xv6s.png)\n然后在终端或者 `powershell` 里输入指令：\n>```powershell\n>ollama run deepseek-r1:7b\n>```\n其中 `7b` 可替换为自己之前选择的选项。\n\n请**耐心**等进度条跑完，这可能会消耗~~几年~~**几小时**的时间。\n![](https://cdn.luogu.com.cn/upload/image_hosting/w1xjpp48.png)\n\n按下回车，就可以对话了！它使用的格式是 Markdown。\n![](https://cdn.luogu.com.cn/upload/image_hosting/426uwjdk.png)\n下面还有好多，就不贴了。\n\n为了方便对话，我们可以下载一个 Chatbox，[官网点这里](https://chatboxai.app/zh)。\n![](https://cdn.luogu.com.cn/upload/image_hosting/r8lzxdz5.png)\n下载完后打开，点击左下角的`设置`按钮，按照上述步骤修改，其余不变。\n![](https://cdn.luogu.com.cn/upload/image_hosting/tdbcgg7a.png)\n  现在就可以交流了！**如果不行的话请重启 Chatbox 再试试！**\n\n**求赞！求关注，必回关！**","categories":["科技·工程"]},{"title":"题解：P1071 [NOIP 2009 提高组] 潜伏者","url":"/2026/02/16/题解：P1071 [NOIP 2009 提高组] 潜伏者/","content":"**原文：<https://www.luogu.com.cn/article/jftnkm89> 点个赞吧！**\n\n---\n不知道为什么大家的做法都那么复杂，只有[一篇题解](/article/vjhqsomd)和我思路差不多。\n## 思路\n这就是个模拟题。我们设读入的三行字符串分别为 $a,b,c$。\n\n一看到题目，就知道可以用 `map` 解题。先设一个 `map<char,char>mp;`，用于整理“密码本”；再设一个 `map<char,bool>vis;`，用于记录哪个字符已经在“密码本”里了。\n\n首先遍历 $a$：如果 $vis_{b_i}=1 \\land b_i \\ne mp_{a_i}$，直接输出 `Failed` 并结束程序；否则，$mp_{a_i} \\gets b_i,vis_{b_i} \\gets 1$。\n\n然后遍历 $\\tt A \\sim Z$，如果 $vis_i=0$，输出 `Failed` 并结束程序。\n\n最后根据“密码本”翻译 $c$ 中的内容并输出。\n## Code\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nstring a,b,c;\nmap<char,char>mp;map<char,bool>vis;\nint main(){\n\tcin>>a>>b>>c;\n\tfor(int i=0;i<a.size();i++){\n\t\tif(vis[b[i]]&&b[i]!=mp[a[i]]){cout<<\"Failed\\n\";return 0;}\n\t\tmp[a[i]]=b[i],vis[b[i]]=1;\n\t}\n\tfor(char i='A';i<='Z';i++){\n\t\tif(!vis[i]){cout<<\"Failed\\n\";return 0;}\n\t}\n\tfor(int i=0;i<c.size();i++) cout<<mp[c[i]];\n}\n```","tags":["模拟","字符串"],"categories":["题解"]},{"title":"题解：P1044 [NOIP 2003 普及组] 栈","url":"/2026/02/16/题解：P1044 [NOIP 2003 普及组] 栈/","content":"**原文：<https://www.luogu.com.cn/article/v9r07ta2> 点个赞吧！**\n\n---\n## 思路\n假设我们用一个函数 $\\operatorname{C}(x,y)$ 表示：\n* $x$：当前还未入栈的数字个数。\n* $y$：当前栈中的数字个数。\n\n我们的目标是计算 $\\operatorname{C}(n,0)$，即从 $n$ 个数字开始，生成输出序列的方式。\n\n在任何状态下，我们有两种选择：\n* push 操作：如果还有数字可以入栈（即 $x>0$），我们可以将一个数字从输入序列中移入栈中。这会减少未入栈的数字个数 $x$，同时增加栈中的数字个数 $y$。因此，该操作对应于 $\\operatorname{C}(x-1,y+1)$。\n* pop 操作：如果栈中有数字可以出栈（即 $y>0$），我们可以将栈顶数字移出到输出序列中。这不会改变未入栈的数字个数 $x$，但会减少栈中的数字个数 $y$。因此，该操作对应于 $\\operatorname{C}(x,y-1)$。\n\n递归的边界条件是：当 $x=0 \\land y=n$ 时，表示所有数字已成功输出为一个序列，这算作一种有效方式，返回 $1$；其他不合法状态（如 $x<0 \\lor y>n$）返回 $0$。\n\n递归太慢，所以我们可以用 DP，转移方程是：\n$$f_{x,y}=f_{x-1,y+1}+f_{x,y-1}$$\n## Code\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint f[20][20],n;\nint main(){\n\tcin>>n;\n\tfor(int x=0;x<=n;x++){\n\t\tfor(int y=0;y<=n;y++){\n\t\t\tif(!x) f[x][y]=1;\n\t\t\telse if(!y) f[x][y]=f[x-1][y+1];\n\t\t\telse f[x][y]=f[x-1][y+1]+f[x][y-1];\n\t\t}\n\t}\n\tcout<<f[n][0];\n}\n```\n有问题请指出！\n\n感谢 @[NJYgocrazy](/user/1418820) 指出一个小错误。","tags":["动态规划 DP","数学","递推","Catalan 数"],"categories":["题解"]},{"title":"题解：P1087 [NOIP 2004 普及组] FBI 树","url":"/2026/02/16/题解：P1087 [NOIP 2004 普及组] FBI 树/","content":"**原文：<https://www.luogu.com.cn/article/o2ttrsv4> 点个赞吧！**\n\n---\n题目其实很简单，直接按照题意递归模拟就完事了。\n## 思路\n定义一个递归函数 $\\operatorname{solve}(l,r)$，其中 $l,r$ 表示当前子串的起始和结束索引。这个函数负责构造索引在 $[l,r]$ 里的子串对应的子树，并返回该子树的类型。\n\n函数里面是这样的：\n* 我们将子串分为左右两部分，用 $mid$ 来表示中间值。\n* 处理左右子树，分别为 $\\operatorname{solve}(l,mid),\\operatorname{solve}(mid+1,r)$。\n* 处理根节点：\n  * 遍历 $[l,r]$，统计 $0$ 和 $1$ 的个数，分别记作 $c_0,c_1$。\n  * 如果 $c_0>0 \\land c_1>0$，输出 `F`；否则如果 $c_0>0$，输出 `B`；否则，输出 `I`。\n\n主函数里面调用 $\\operatorname{solve}(0,2^n-1)$ 即可（这是下标从 $0$ 开始的代码，若下标从 $1$ 开始，则为 $\\operatorname{solve}(1,2^n)$）。\n## Code\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nstring s;int n;\nvoid solve(int l,int r){\n\tint mid=(l+r)/2,c0=0,c1=0;\n\tif(l!=r) solve(l,mid),solve(mid+1,r);\n\tfor(int i=l;i<=r;i++){\n\t\tif(s[i]=='0') c0++;\n\t\telse c1++;\n\t}\n\tif(c0&&c1) cout<<'F';\n\telse if(c0) cout<<'B';\n\telse cout<<'I';\n}\nint main(){\n\tcin>>n>>s,solve(0,pow(2,n)-1);\n}\n```","tags":["字符串","搜索","树形数据结构","递归"],"categories":["题解"]},{"title":"题解：P11996 我是黄色恐龙大将军","url":"/2026/02/16/题解：P11996 我是黄色恐龙大将军/","content":"**原文：<https://www.luogu.com.cn/article/25qthmcm> 点个赞吧！**\n\n---\n## 思路\n首先，我们需要明确题目要求的是**所有可能的** $a_n \\times b_n$ 的值的和，且**相同的值只计算一次**。因此，我们需要找到所有 $n$ 对应的 $a_n \\times b_n$，然后去重求和。\n* $a_n$ 是 $2^n$ 的最高非零位。\n* $b_n$ 是 $5^n$ 的最高非零位。\n\n我们计算 $a_n \\times b_n$ 的前几项：\n* $n=1$：$2^1=2,a_1=2,5^1=5,b_1=5,a_1 \\times b_1=10$。\n* $n=2$：$2^2=4,a_2=4,5^2=25,b_2=2,a_2 \\times b_2=8$。\n* $n=3$：$2^3=8,a_3=8,5^3=125,b_3=1,a_3 \\times b_3=8$。\n\n以此类推……\n\n我们发现从 $n=1 \\sim 30$ 的计算中，$a_n \\times b_n$ 的值有：\n$$10,8,8,6,9,6,7,6,5,9,8,8,8,6,9,6,7,6,5,9, 8,8,8,5,6,6,7,6,5,9$$\n去重后只剩：\n$$5,6,7,8,9,10$$\n将这些值相加：\n$$5+6+7+8+9+10=45$$\n答案就是 $45$。\n## 证明\n对于任意正整数 $k$，其最高非零位数字可以通过 $k$ 除以 $10^{\\lfloor\\log_{10}k\\rfloor}$ 并取整数部分得到。因此，$a_n=\\lfloor \\frac{2^n}{10^{\\lfloor n \\log_{10}2 \\rfloor}}\\rfloor,b_n=\\lfloor \\frac{5^n}{10^{\\lfloor n \\log_{10}5\\rfloor}}\\rfloor$。\n\n注意到 $\\log_{10}(2 \\times 5)=\\log_{10}10=1$，因此 $\\log_{10}2+\\log_{10}5=1$。设 $\\alpha=\\log_{10}2\\approx0.3010$，则 $\\log_{10}5=1-\\alpha\\approx0.6990$。\n\n$2^n$ 的十进制表示的位数是 $\\lfloor n \\alpha \\rfloor+1$；$5^n$ 的十进制表示的位数是 $\\lfloor n(1-\\alpha)\\rfloor+1$。$a_n$ 和 $b_n$ 的值主要由 $\\{n\\alpha\\}$ 和 $\\{n(1-\\alpha)\\}$ 决定，其中 $\\{x\\}$ 表示 $x$ 的小数部分。\n\n由于 $\\alpha$ 是无理数，序列 $\\{n\\alpha\\}$ 在区间 $[0,1)$ 上是均匀分布的。因此，$\\{n(1-\\alpha)\\}=1-\\{n\\alpha\\}$ 也是均匀分布的。\n\n$a_n$ 的值由 $2^n$ 的最高位决定，可以表示为 $\\lfloor 10^{\\{n\\alpha\\}}\\rfloor$；$b_n$ 的值由 $5^n$ 的最高位决定，可以表示为 $\\lfloor 10^{\\{n(1-\\alpha)\\}}\\rfloor=\\lfloor 10^{1-\\{n\\alpha\\}}\\rfloor$。因此，$a_n \\times b_n=\\lfloor 10^{\\{n\\alpha\\}}\\rfloor \\times \\lfloor 10^{1-\\{n\\alpha\\}}\\rfloor$。\n\n我们需要找到所有可能的 $\\lfloor 10^x \\rfloor \\times \\lfloor 10^{1-x} \\rfloor$ 的值，其中 $x \\in [0,1)$。\n* 对于 $x\\in[0,\\log_{10}2),\\lfloor 10^x \\rfloor=1,\\lfloor 10^{1-x}\\rfloor \\in \\{5,6,7,8,9,10\\}$：$1 \\times 5=5,1 \\times 6=6,1 \\times 7=7,1 \\times 8=8,1 \\times 9=9,1 \\times 10=10$。\n* 对于 $x\\in[\\log_{10}2,\\log_{10}3),\\lfloor 10^x \\rfloor=2,\\lfloor 10^{1-x}\\rfloor \\in \\{4,5\\}$：$2 \\times 4=8,2 \\times 5=10$。\n* 对于 $x\\in[\\log_{10}3,\\log_{10}4),\\lfloor 10^x \\rfloor=3,\\lfloor 10^{1-x}\\rfloor \\in \\{3,4\\}$：$3 \\times 3=9,3 \\times 4=12$（但 $12$ 不会出现，因为 $10^{1-x}$ 不会达到 $4$）。\n\n所以乘积不会超过 $10$。\n\n**有问题请指出！**","tags":["数学","枚举"],"categories":["题解"]},{"title":"题解：P12605 求和","url":"/2026/02/16/题解：P12605 求和/","content":"**原文：<https://www.luogu.com.cn/article/2jyyggc1> 点个赞吧！由于 $\\LaTeX$ 公式有点炸了，所以在原文食用效果更佳！**\n\n---\n## 思路\n把题意转化一下，我们需要计算 $s_1+s_2+\\cdots+s_n$ 和 $t_1+t_2+\\cdots+t_n$ 的表达式。\n\n首先计算前缀和的总和：\n$$S=\\sum_{k=1}^ns_k=\\sum_{k=1}^n\\sum_{i=1}^ka_i=\\sum_{i=1}^na_i \\cdot (n-i+1)$$\n这是因为每个 $a_i$ 在 $s_i,s_{i+1},\\cdots,s_n$ 中出现了 $(n-i+1)$ 次。\n\n我们用同样的方法计算后缀和的总和：\n$$T=\\sum_{k=1}^nt_k=\\sum_{k=1}^n\\sum_{i=k}^na_i=\\sum_{i=1}^na_i \\cdot i$$\n这是因为每个 $a_i$ 在 $t_1,t_2,\\cdots,t_i$ 中出现了 $i$ 次。\n\n因此，等式 $S=T$ 可表示为：\n$$\\begin{aligned}\n\\sum_{i=1}^na_i \\cdot (n-i+1)&=\\sum_{i=1}^na_i \\cdot i\\\\\n\\sum_{i=1}^na_i \\cdot (n-i+1)-\\sum_{i=1}^na_i \\cdot i&=0\\\\\n\\sum_{i=1}^na_i \\cdot (n-i+1-i)&=0\\\\\n\\sum_{i=1}^na_i \\cdot (n-2i+1)&=0\n\\end{aligned}\n$$\n记 $c_i=n-2i+1$，则条件为：\n$$\\sum_{i=1}^na_i \\cdot c_i=0$$\n我们设初始偏差为 $D$，计算初始的 $D=\\sum\\limits_{i=1}^na_i \\cdot c_i$\n我们每次可以选择 $i$ 和 $j$，$D$ 的变化为 $c_i-c_j=2(j-i)$。因此，每次操作可以调整 $D$ 的值为 $\\pm2(j-i)$。为了最小化操作次数，应尽可能选择最大的 $|j-i|$，即 $i=1,j=n$，此时 $|\\Delta|=2(n-1)$。\n\n* 如果 $D$ 是奇数，显然无法通过偶数次调整得到 $0$，直接返回 $-1$。\n* 如果 $D$ 是偶数，最小操作次数为 $\\lceil\\frac{|D|}{2(n-1)}\\rceil$。\n## Code\n```cpp\n#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int maxn=1e6+5;\nll n,a[maxn],d;\nint main(){\n\tcin>>n;\n\tfor(ll i=1;i<=n;i++) cin>>a[i];\n\tif(n==1){cout<<0;return 0;}\n\tfor(ll i=1;i<=n;i++){\n\t\tll c=n-i*2+1;\n\t\td+=a[i]*c;\n\t}\n\tif(d%2) cout<<-1;\n\telse cout<<(abs(d)+2*(n-1)-1)/(2*(n-1));\n}\n```\n注意：\n* 要开 `long long`。\n* 要特判 $n=1$ 的情况，因为如果这样的话 $n-1=0$，会导致除零错误，会 `RE`。\n* 如果使用 `ceil` 向上取整的话会出现浮点误差，所以推荐使用代码中的写法进行向上取整。","tags":["贪心","前缀和"],"categories":["题解"]},{"title":"题解：P1431 找出伪币","url":"/2026/02/16/题解：P1431 找出伪币/","content":"**原文：<https://www.luogu.com.cn/article/0z1js5qr> 点个赞吧！**\n\n---\n## 思路\n每次 $p$ 就只有两种状态：\n* 当 $p \\ne 0$ 时。每次称重有 $3$ 种可能结果（左重、右重、平衡），可产生 $\\log_3 3=1$ 个三进制位的信息量，区分 $n$ 个不同情况需要 $\\lceil \\log_3 n \\rceil$ 次称重。所以最少称量次数 $m$ 满足 $3^m \\ge n$，即 $m = \\lceil \\log_3 n \\rceil$。\n* 当 $p=0$ 时。这个时候我们不仅需要定位伪币，还需确定其轻重，每个硬币有 $2$ 种可能性（可能轻或重），总可能性为 $2n$ 种，最少需要区分 $2n+3$ 种情况。证明的话可以去看其他题解，这里不再赘述。所以最少称量次数 $m$ 满足 $3^m \\ge 2n + 3$，即 $m=\\lceil \\log_3 (2n+3) \\rceil$。\n\n然而，这道题目的关键点在于高精度，普通高精被卡，只能用压位高精……我写的是 $18$ 位压位存储，时间复杂度 $\\Theta(\\frac{Tk^2}{18^2})=\\Theta(\\frac{Tk^2}{324})$。\n## Code\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst long long BASE=1e18;//定义大数的基数为 1e18（每位存储 18 位十进制数）\nconst int BASE_DIGITS=18;\nvector<long long>sto(string s){//字符串转大数（按 18 位分割存储）\n\tvector<long long>res;\n\tfor(int i=s.size();i>0;i-=BASE_DIGITS){//从字符串末尾开始，每次处理 18 位\n\t\tint start=max(0,i-BASE_DIGITS);//计算当前段的起始位置\n\t\tstring part=s.substr(start,i-start);//截取 18 位字符串\n\t\tres.push_back(stoll(part));//转换为 long long 并存入 vector\n\t}\n\treturn res;\n}\nvector<long long>mul(vector<long long>a,int b){//大数乘法\n\tvector<long long>res;\n\tlong long c=0;//进位\n\tfor(long long x:a){//逐位相乘\n\t\tlong long p=x*b+c;//当前位乘积+进位\n\t\tres.push_back(p%BASE),c=p/BASE;//取模得到当前位并计算新的进位\n\t}\n\twhile(c) res.push_back(c%BASE),c/=BASE;//处理剩余进位\n\treturn res;\n}\nvector<long long>add(vector<long long> a,vector<long long> b){//大数加法\n\tvector<long long>res;\n\tlong long c=0;//进位\n\tfor(int i=0;i<max(a.size(),b.size())||c;i++){//逐位相加（处理不等长情况）\n\t\tlong long sum=c;\n\t\tif(i<a.size()) sum+=a[i];\n\t\tif(i<b.size()) sum+=b[i];\n\t\tres.push_back(sum%BASE),c=sum/BASE;//取模得到当前位并计算新的进位\n\t}\n\treturn res;\n}\nbool cmp(vector<long long>a,vector<long long>b){//大数比较\n\tif(a.size()!=b.size()) return a.size()>b.size();//先比较位数\n\tfor(int i=a.size()-1;i>=0;i--){//从高位到低位逐位比较\n\t\tif(a[i]!=b[i]) return a[i]>b[i];\n\t}\n\treturn true;\n}\nint solve(string s,bool f){\n\tvector<long long>t=sto(s);\n\tif(f){//如果需要特殊计算\n\t\tt=mul(t,2);\n\t\tvector<long long>k={3};\n\t\tt=add(t,k);\n\t}\n\tvector<long long>a={1};\n\tint m=0;//幂次计数\n\twhile(!cmp(a,t)) a=mul(a,3),m++;//不断乘 3 直到大于等于目标值\n\treturn m;\n}\nint main(){\n\tios::sync_with_stdio(0),cin.tie(0);\n\tint T;cin>>T;\n\twhile(T--){\n\t\tint k,p;string n;cin>>k>>p>>n;\n\t\tbool f=(p==0);//特判\n\t\tcout<<solve(n,f)<<'\\n';\n\t}\n}\n```\n有问题请指出！","tags":["数学","高精度"],"categories":["题解"]},{"title":"题解：P6842 [BalkanOI 2009] Strip","url":"/2026/02/16/题解：P6842 [BalkanOI 2009] Strip/","content":"**原文：<https://www.luogu.com.cn/article/fgtc7gov> 点个赞吧！**\n\n---\n感觉其他题解有点难懂，这里发一篇通俗的。\n## 思路\n我们维护两个变量 $l,r$ 分别表示当前条带的左右端点，再维护一个数组 $t$ 表示**翻折（即“对称轴”）的实际位置**。\n\n因为往右边翻可以保证 $l \\ge 0,r \\ge 0$，所以我们**统一往右边翻**。\n\n我们考虑一个问题：对于对称轴 $s$ 折叠后，原来位置 $x$ 的点现在在哪里？\n* 如果 $x \\ge s$：还在原来的位置。\n* 如果 $x<s$：被翻到右边，新位置为 $2s-x$。\n\n我们设每次读进来的“对称轴”为 $a$。但由于经过了翻折，$a$ 对应的是原条带的下标，而我们要的是当前的实际下标。所以我们要求出，经过前 $i-1$ 次折叠后，原始位置 $a$ 在当前条带中的实际位置是多少？\n\n设 $f(x)$ 表示原始位置 $x$ 经过所有折叠后的实际位置。对于第 $j$ 次折叠在位置 $t_j$：\n* 如果 $f(x) \\ge t_j$：保持不变。\n* 如果 $f(x)<t_j$：那么 $f(x)=2 \\times t_j-f(x)$。\n\n由此我们可以得到 $a$ 每次操作得到的实际位置是 $a=\\max(a,2 \\times t_j-a)$，需要进行 $i-1$ 次翻折操作才能求出 $a$ 的实际位置。\n\n我们知道了“对称轴”的位置，就可以求出 $l,r$ 的值啦！$r$ 的位置变成了 $r$ 和 $l$ 的对称点的最大值（因为翻折后 $r$ 有可能会超过原来右端点的位置，也有可能不超过，所以取最大值），$l$ 的位置变成了 $a$ 的位置，我们根据上面的公式可得出 $r=\\max(r,2a-l),l=a$。\n\n**注意不能交换操作顺序，必须先更新 $r$ 再更新 $l$，因为 $r$ 的计算需要旧的 $l$ 值。否则只有 $28$ 分……。**\n\n由于题目中的长度定义为**两端点之间的距离**，而我们的 $l,r$ 是条带的左右端点位置，因此输出 $r-l$ 即可得到正确的条带长度，不要输出 $r-l+1$。\n\n代码和楼上楼下差不多，就不贴了。","tags":["数学","模拟"],"categories":["题解"]},{"title":"CSP-J/S 2025 游记","url":"/2026/02/16/CSP-JS 2025 游记/","content":"**原文：<https://www.luogu.com.cn/article/4mazvyjo> 点个赞吧！**\n\n---\n## 前言\n[前景摘要](https://www.luogu.com.cn/article/dc2jdedt)。\n\n这是我第一次 CSP 进复赛，必须记录一下！\n## 初赛\n### Day#0\n上初一了，晚上写了会儿作业，没时间开电脑。\n### Day#1\n#### 赛前\n早上 4:30 就行了，开电脑，复习。\n\n抽了一下运势，还是 `中吉`。\n\n早上出发去镇海蛟川书院，那里人好多啊，感觉再晚一点就来不及了。\n#### CSP-J\n拿到试卷赶紧翻了一下，发现题目还可以，长输了一口气。\n\n然后就开始疯狂地写试卷，刷刷刷奋笔疾书，废了好几页草稿纸，有一题我直接模拟 $O(n!)$，此间一切顺利。\n#### 中午\n出考场后，我发现我被第一题坑了，题目说的是**无符号**……\n\n估分，发现各个平台估出来的分都不一样（差距还挺大），就躺平了。在肯德基吃了一个汉堡，背了一会 whk，就又出发了。\n#### CSP-S\n已经做足了心理准备，该做的做，该猜的猜，胡乱写完了。\n\n当我看到代码中有一个 `You have no egg.` 的时候，我差点喷出来。\n#### 赛后\nJ 组估分 $81 \\pm 5$，S 组估分 $60 \\pm 10$。结果最后 J 组得了 $79$，S 组得了 $66$，都进了复赛。唯一遗憾的是，S 组一等线为 $66.5$，就差半分就可以一等了！/kel\n## 复赛\n### Day#0\n下午提早从学校出来，去赶六点钟的动车，可惜是无座票，只能一边站着一边背道法了（腿真的好累啊 awa）。到达杭州东后，上出租车去酒店，我爸和司机聊了一路。来到酒店，坐了一会儿 whk 作业，复习了一会 CSP 就睡了。\n### Day#1\n#### 赛前\n一大早起来吃早餐，然后就出发了，一会儿就抵达杭州师范大学下沙校区了。\n#### CSP-J\n开题！发现题目好简单呀。\n\nT1&T2 直接秒了。\n\nT3 没有把握，只会写一个前缀异或和+错误贪心思路，感觉肯定会 WA。\n\nT4 只会写暴力，但是在赛场上忘记 `next_permutation` 怎么用了，就临时写了个 dfs，顺便写了个对拍，应该没问题。\n#### 中午\n我爸去保安那要了一个二维码，进了食堂，感觉饭菜还可以。但是我没时间估分了。\n#### CSP-S\n下午 T1 想出了贪心思路但发现思路假了，直接崩溃，然后调暴力，感觉只能拿 $25$ 分。\n\nT2 感觉有点复杂，懒得写（其实是因为 T1 已经调了 2h 了），直接水了一个乱搞代码，预估分数 $0$。\n\nT3 看不懂在干什么，直接总司令，预估分数 $0$。\n\nT4 看懂了但是不知道怎么写，就水了个特殊性质。\n#### 赛后\nJ 组估分 $100+100+30+40=270$，但实际分数为 $100+100+20+40=260$，真的不知道 T3 为什么会挂了 $10$ 分；S 组估分 $25+0+0+0=25$，但实际分数为 $35+0+0+4=39$，有点神奇。没能拿到 NOIP 资格……\n## 后记\n这次不知道能不能拿到一等+五级钩（大概率没了），明年再战！CSP-2026 RP++！","tags":["2025"],"categories":["生活·游记"]},{"title":"必看","url":"/2026/02/16/必看/","content":"这里是 [\\_\\_CJY__](https://www.luogu.com.cn/user/1086453) 的个人博客，在这里你可以看到：\n* 精美的学习笔记\n* 逻辑清晰的题解${}^{\\tt 1}$\n* 惊心动魄的游记\n\n${}^{\\tt 1}$：特别的，这里只记录在[洛谷](https://www.luogu.com.cn/)上深受好评的**优质**题解，如果你想看到我的所有文章，请[截这里](https://www.luogu.com.cn/user/1086453/article)！\n\n**另外，这是[我的私信](https://www.luogu.com.cn/chat?uid=1086453)，欢迎交流、勘误，也希望你们在我的洛谷专栏上能多多点赞！**\n\n***祝你看得开心！***","categories":["重要杂文"]},{"title":"题解：P14954 520","url":"/2026/02/15/题解：P14954 520/","content":"**原文：<https://www.luogu.com.cn/article/cvw7gi8f> 点个赞吧！**\n\n---\n感觉其他题解讲的都不太清楚，我来讲讲，可能有些重复，请见谅！\n## 思路\n1. 首先先把已有的 $520$ 找出来，并将它们标记为空。\n2. 再把缺一个数字的（即 $52,20,50$）算上。\n3. 按照“优先使用当前最不稀缺的插入字符”的贪心策略用单个字符加两个插入字符形成 $520$。\n4. 剩下的插入字符直接组成完整的 $520$，加上。\n## Code\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint T,n,a,b,c,res,s1,s2,s3;\nint main(){\n\tcin>>T;\n\twhile(T--){\n\t\tcin>>n>>a>>b>>c,res=s1=s2=s3=0;\n\t\tstring s;cin>>s;\n\t\tfor(int i=0;i<n-2;i++){//第一步\n\t\t\tif(s.substr(i,3)==\"520\") res++,s[i]=s[i+1]=s[i+2]=' ';\n\t\t}\n\t\tfor(int i=0;i<n-1;i++){//第二步\n\t\t\tif(s.substr(i,2)==\"52\"&&c) res++,c--,s[i]=s[i+1]=' ';\n\t\t\telse if(s.substr(i,2)==\"20\"&&a) res++,a--,s[i]=s[i+1]=' ';\n\t\t\telse if(s.substr(i,2)==\"50\"&&b) res++,b--,s[i]=s[i+1]=' ';\n\t\t}\n\t\tfor(int i=0;i<n;i++){//统计三种数字的个数\n\t\t\tif(s[i]=='5') s1++;\n\t\t\telse if(s[i]=='2') s2++;\n\t\t\telse if(s[i]=='0') s3++;//注意这里不能用 else，因为 s[i] 有可能为空格\n\t\t}\n\t\twhile(s1||s2||s3){//第三步\n\t\t\tif(a>=c&&b>=c&&s3&&a&&b) res++,s3--,a--,b--;//如果 a 和 b 都 >= c，且有 0 可用，则消耗 a 和 b\n\t\t\telse if(a>=b&&c>=b&&s2&&a&&c) res++,s2--,a--,c--;//同上\n\t\t\telse if(b>=a&&c>=a&&s1&&b&&c) res++,s1--,b--,c--;//同上\n\t\t\telse break;\n\t\t}\n\t\tres+=min({a,b,c}),cout<<res<<'\\n';//第四步\n\t}\n}\n```","tags":["贪心"],"categories":["题解"]}]