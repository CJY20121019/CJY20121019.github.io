[{"title":"题解：CF393B Three matrices","url":"/2026/02/16/题解：CF393B Three matrices/","content":"**原文：<https://www.luogu.com.cn/article/xyoaxhpt> 点个赞吧！**\n\n---\n**这是一道简单的模拟题**\n### 思路\n1. 我们先把 $W$ 矩阵读入进来。\n2. 然后根据题意，对 $W,A,B$ 数组进行模拟。由：\n\n* $ A_{i,j}=A_{j,i} $\n\n* $ B_{i,j}=-B_{j,i} $\n\n* $ W_{i,j}=A_{i,j}+B_{i,j} $\n\n\n可得出：\n\n* $ A_{i,j}=A_{j,i} $ \n\n* $ B_{i,j}=-B_{j,i} $\n\n* $ W_{i,j}-W_{j,i}=B_{i,j} \\times 2 $\n\n3. 操作完毕后，输出 $A,B$ 数组就行了。\n### Code\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ndouble a[171][171],b[171][171],w[171][171];\nint main(){\n\tint n;cin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++) cin>>w[i][j];\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tdouble t=w[i][j]-w[j][i];\n\t\t\tt*=0.5,b[i][j]=t,a[i][j]=w[i][j]-b[i][j],b[j][i]=-t,a[j][i]=w[j][i]-b[j][i];\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++) printf(\"%.8lf \",a[i][j]);\n\t\tcout<<endl;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++) printf(\"%.8lf \",b[i][j]);\n\t\tcout<<endl;\n\t}\n}\n```","tags":["模拟"],"categories":["题解"]},{"title":"题解：SP64 PERMUT1 - Permutations","url":"/2026/02/16/题解：SP64 PERMUT1 - Permutations/","content":"**原文：<https://www.luogu.com.cn/article/88t0ujch> 点个赞吧！由于 $\\LaTeX$ 公式有点炸了，所以在原文食用效果更佳！**\n\n---\n## 题意简述\n对于一个数列 $a_i$，如果有 $i<j$ 且 $a_i>a_j$，那么我们称它们为一对逆序对数。对于一个由 $1 \\sim n$ 组成的排列，可以很容易求出有多少个逆序对数。求逆序对数为 $m$ 的排列有多少个？答案对 $10000$ 取模。\n## 解题思路\n设 $f_{i,j}$ 表示由 $1$ 到 $i$ 组成的所有排列中，逆序对数量为 $j$ 的排列个数。\n考虑把数字 $i$ 插入到之前的排列中。将数字 $i$ 插入到位置 $k$ 后，会产生 $i-k-1$ 个逆序对数。\n$$f_{i,j}=\\sum_{k=0}^{i-1}f_{i-1,j-(i-k-1)}=\\sum_{k=\\max(0,j-i+1)}^{j}f_{i-1,k}$$\n时间复杂度 $O(n^2 \\cdot k)$ 无法通过本题。\n\n我们需要转移的同时记录**前缀和**，设：\n$$s_{i,j}=\\sum_{k=0}^{j}f_{i,k}$$\n那么：\n$$\nf_{i,j}=\n\\begin{cases}\ns_{i-1,j}-s_{i-1,j-i}&,j-i \\le 0\\\\\ns_{i-1,j}&,j-i<0\n\\end{cases}$$\n## Code\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint f[100][100]={{1}},s[100][100],n,k;\nint main(){\n\tint T;cin>>T;\n\twhile(T--){\n\t\tcin>>n>>k;\n\t\tfor(int i=0;i<=k;i++) s[0][i]=1;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=0;j<=k;j++){\n\t\t\t\tf[i][j]=s[i-1][j];\n\t\t\t\tif(j-i>=0) f[i][j]-=s[i-1][j-i];\n\t\t\t\ts[i][j]=f[i][j];\n\t\t\t\tif(j) s[i][j]+=s[i][j-1];\n\t\t\t}\n\t\t}\n\t\tcout<<f[n][k]<<endl;\n\t}\n}\n```\n## 后记\n此外，这题有***四倍经验***！\n\n它们是：[P1521 求逆序对](https://www.luogu.com.cn/problem/P1521)、[P2513 [HAOI2009] 逆序对数列](https://www.luogu.com.cn/problem/P2513)、[P6323 [COCI2006-2007#4] ZBRKA](https://www.luogu.com.cn/problem/P6323)和[本题](https://www.luogu.com.cn/problem/SP64)！\n### [P1521 求逆序对](https://www.luogu.com.cn/problem/P1521) Code\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=10000;\nint f[105][5005]={{1}},s[105][5005],n,k;\nint main(){\n\tcin>>n>>k;\n\tfor(int i=0;i<=k;i++) s[0][i]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<=k;j++){\n\t\t\tf[i][j]=s[i-1][j];\n\t\t\tif(j-i>=0) f[i][j]-=s[i-1][j-i];\n\t\t\ts[i][j]=f[i][j];\n\t\t\tif(j) s[i][j]+=s[i][j-1];\n\t\t\tf[i][j]%=mod,s[i][j]%=mod;\n\t\t}\n\t}\n\tcout<<(f[n][k]+mod)%mod;\n}\n```\n### [P2513 [HAOI2009] 逆序对数列](https://www.luogu.com.cn/problem/P2513) Code\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=10000;\nint f[1005][1005]={{1}},s[1005][1005],n,k;\nint main(){\n\tcin>>n>>k;\n\tfor(int i=0;i<=k;i++) s[0][i]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<=k;j++){\n\t\t\tf[i][j]=s[i-1][j];\n\t\t\tif(j-i>=0) f[i][j]-=s[i-1][j-i];\n\t\t\ts[i][j]=f[i][j];\n\t\t\tif(j) s[i][j]+=s[i][j-1];\n\t\t\tf[i][j]%=mod,s[i][j]%=mod;\n\t\t}\n\t}\n\tcout<<(f[n][k]+mod)%mod;\n}\n```\n### [P6323 [COCI2006-2007#4] ZBRKA](https://www.luogu.com.cn/problem/P6323) Code\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7,maxn=1e3+5,maxc=1e4+5;\nint f[2][maxc],s[2][maxc],n,c,x=1,y;\nint main(){\n    cin>>n>>c;\n    f[1][0]=s[1][0]=1;\n    for(int i=1;i<=c;i++) s[1][i]=1;\n    for(int i=2;i<=n;i++){\n\t\tswap(x,y),f[x][0]=s[x][0]=1;\n        for(int j=1;j<=c;j++){\n            f[x][j]=s[y][j];\n            if(j-i>=0) f[x][j]=(f[x][j]-s[y][j-i])%mod;\n            s[x][j]=(s[x][j-1]+f[x][j])%mod;\n        }\n    }\n    if(f[x][c]<0) f[x][c]+=mod;\n    cout<<f[x][c];\n}\n```\n**大差不差，都一样！看在我给四倍经验和`std`的份儿上，点个赞吧！**","tags":["动态规划 DP","前缀和","线性 DP"],"categories":["题解"]},{"title":"CSP-J 2024 游记","url":"/2026/02/16/CSP-J 2024 游记/","content":"**原文：<https://www.luogu.com.cn/article/dc2jdedt> 点个赞吧！由于 $\\LaTeX$ 公式有点炸了，所以在原文食用效果更佳！**\n\n---\n# 我的信息\n|省份|城市|所在区|坐标|性别|年龄|学校|\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n|$浙江省$|$宁波市$|$鄞州区$|$\\texttt{ZJ/NB/YZ}$|$男$|$12$|$堇山小学$|\n# 初赛\n## Day $-365+[5,15]$\n`CSP`$2023$ 的成绩出来了，我考了 $43$ 分，毫无悬念地没进复赛，当年 $\\texttt{ZJ}$ 分数线：$72$，拿了**全国三等**！\n\n那时，我决定发奋图强，正取 $2024$ 年进复赛。\n## Day $-1$\n这一天是周五，一回到家我赶紧肝完作业，肝起了初赛。这天晚上我哪儿也没去，紧赶慢赶终于把往年真题和洛谷SCP刷完了！\n## Day $1$\n### 赛前\n这一天我早早地起了床，吃完早饭后，我抽了一下运势，发现是：\n$$\n\\color{orange}陈嘉逸2012\\color{black}\\ 的运势\\\\\n\\color{red}\\huge§\\ 中吉\\ §\\\\\n$$\n$$\n\\color{red}宜：参加 CSP\\color{black}\\  \\  \\ 忌：体育锻炼\\\\\n\\color{red}祝你 RP++\\  \\  \\ \\color{black}消耗的能量全吃回来了\\\\\n\\color{red}宜：出公开赛\\color{black}\\  \\  \\ 忌：抽卡\\\\\n\\color{red}rated，评价很高\\  \\  \\ \\color{black}只有保底\n$$\n从那一刻起，我就知道了，今年有没进复赛……\n\n到 $\\texttt{镇海蛟川书院}$ 以后，我等了好久。终于能进考场了，里面有空调！~~比我们学校好多了。~~\n### 赛时\n卷子发下来了，我阅览了一遍，发现怎么那么简单！比平时刷的卷子简单多了！\n\n就这样我开始奋笔疾书，可是第一题难住了我，我没有复习过`INT_MIN`和`INT_MAX`。还有一题格雷码，也不会。\n\n选择题做完了，我开始做阅读程序题。发现简单多了，模拟一遍就行了，码量也很少，顶多一个`递归`或`DP`。\n\n我开始肝程序填空题了。第一道很简单。第二道汉诺塔问题之前准备区赛时做到过，可是忘了，只能自己想了。~~结果有一道本来是对的题目最后被我改错了，呜呜！~~\n### 赛后\n出校门以后，我高高兴兴地更爸爸说：“这次很简单，应该能进复赛！”爸爸却开兴不起来，他说他在校门口听见很多人也是这么说的，大家都觉得简单，分数线也会增加的。我也高兴不起来了。\n## Day $[5,15]$\n终于出分数线了，考了 $81$ 分，而分数线是 $89$，没进复赛。\n\n不过，为这次的分数超过了去年的 $\\texttt{ZJ}$ 分数线整整 $9$ 分，而且拿了**全国一等**，还是挺开心的！\n# 复赛\n虽然我没进复赛，可是我参加了洛谷的[CSP-J 2024 自测](https://www.luogu.com.cn/contest/209924)。\n\n我发现第一题特别简单，我能用两种方法秒了。\n\n### [P11227 [CSP-J 2024] 扑克牌](https://www.luogu.com.cn/problem/P11227) Code#1\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nmap<string,bool>mp;\nint n,ans;\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tstring s;cin>>s;\n\t\tif(!mp[s]) ans++,mp[s]=1;\n\t}\n\tcout<<52-ans;\n}\n```\n### [P11227 [CSP-J 2024] 扑克牌](https://www.luogu.com.cn/problem/P11227) Code#2\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nset<string>s;\nint main(){\n\tint n;cin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tstring t;cin>>t;\n\t\ts.insert(t);\n\t}\n\tcout<<52-s.size();\n}\n```\n第二题也过了，再此不贴代码了。\n\n第三、四两题我看都没看，看这难度就知道了。\n# 后记\n我明年会同时参加 $\\texttt{J}$ 和 $\\texttt{S}$，预祝我进复赛！","tags":["2024"],"categories":["生活·游记"]},{"title":"题解：B4048 [语言月赛 202410] 断章取义","url":"/2026/02/16/题解：B4048 [语言月赛 202410] 断章取义/","content":"**原文：<https://www.luogu.com.cn/article/n6rtx0xe> 点个赞吧！**\n\n---\n## 前言\n**Update in $2024/11/17 \\sim 2024/11/20$**\n\n[题目传送门](https://www.luogu.com.cn/problem/B4048)。\n\n**这题似乎有坑，搞了半天！~可能对别的大佬来说很简单！~**\n## 思路\n我们使用`string`提供的`find`函数直接搜索字符串中是否存在子串 $\\texttt{not}$，每次让计数器自增一。\n\n你会获得 $10$ 分。\n\n题目中说，每一轮剪辑找到 $S$ 中所有子串 $\\texttt{not}$，而我的代码中一次只找一次，所以会`WA`。\n\n设 $S=\\texttt{notnot}$。\n\n* **错误方法**：第一轮结束后 $S=\\texttt{not}$，第二轮结束后 $S$ 为空，剪辑轮数为 $2$。\n* **正确方法**：第一轮把所有 $\\texttt{not}$ 删了，$S$ 为空，剪辑轮数为 $1$。\n\n我们每次遍历一遍 $S$，用`substr`判断是否有 $\\texttt{not}$，如果有就用`erase`删除 $\\texttt{not}$。\n\n你会获得 $70$ 分。\n\n设 $i$ 为循环变量，删除 $\\texttt{not}$ 之后就不应该`i++`了，否则就会少检测一次。\n\n设 $S=\\texttt{notnot}$。\n\n第一轮把 $\\texttt{not}$ 删掉，$S=\\texttt{not}$，当前 $i$ 为 $0$，每次循环都会`i++`，所以 $i$ 变成 $1$ 了，此时 $S_i=\\texttt{o}$，就检测不到下一个 $\\texttt{not}$ 了。\n\n我们循环时不写`i++`，当 $s_i,s_{i+1},s_{i+2} \\ne \\texttt{not}$ 时才`i++`。\n\n如果你是像我这样写的话，你就错了：\n```cpp\nfor(int i=0;i<s.size()-2;)\n```\n你会获得 $90$ 分，有一个`RE`。\n\n`s.size()`的类型是`size_t`，`size_t`只能存无符号整数，故不能存负数，当 $|s|<2$ 时，$|s|-2<0$，这样会溢出，并变成一个很大的整数，所以会越界。\n\n我们将`s.size()`强制转整。\n\n这样就 $100$ 分了！\n## Code\n```cpp\nwhile(s.find(\"not\")!=string::npos){\n\tfor(int i=0;i<(int)s.size()-2;){\n\t\tif(s.substr(i,3)==\"not\") s.erase(i,3);\n\t\telse i++;\n\t}\n\tc++;\n}\n```\n\n## 总结\n所以我们以后要养成好习惯，尽量把`s.size()`强制转整。","tags":["字符串"],"categories":["题解"]},{"title":"题解：P11279 「GFOI Round 2」Abstract String Basic","url":"/2026/02/16/题解：P11279 「GFOI Round 2」Abstract String Basic/","content":"**原文：<https://www.luogu.com.cn/article/z64g9ch7> 点个赞吧！由于 $\\LaTeX$ 公式有点炸了，所以在原文食用效果更佳！**\n\n---\n看没人发题解，我来发一篇题解。\n## 题意简述\n给定一个仅由小写字母组成的字符串 $S$，构造另一个仅由小写字母组成的字符串 $T$，使得 $\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^n[i \\ne j][S_i \\ne T_j]$ 最大化，$1 \\le n \\le 10^6$。\n## 思路\n显然暴力不行（~~我也不知道怎么暴力~~）。\n\n我们来推一波式子。\n$$\n\\begin{aligned}\n\\tilde\\psi(S,T)\n&=\\sum_{i=1}^n\\sum_{j=1}^n[i\\neq j][S_i\\neq T_j]\\\\\n&=n(n-1)-\\sum_{i=1}^n\\sum_{j=1}^n[i \\ne j][S_i=T_j]\n\\end{aligned}$$\n$\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^n[i\\neq j][S_i\\neq T_j]$ 是 $S_i \\ne T_j$ 的数量，我们用 $x$ 表示；$n(n-1)$ 是所有 $i \\ne j$ 的数量，因为每行有一个 $i=j$ 的元素，共有 $n$ 行，我们用 $s$ 表示；$\\sum\\limits_{i=1}^n\\sum\\limits_{j=1}^n[i \\ne j][S_i=T_j]$ 是 $S_i=T_j$ 的数量，我们用 $t$ 表示。\n\n由此我们可以得出：\n$$x=s-t$$\n要使 $x$ 最大，我们要最小化 $t$。\n\n对于每一个 $T_i$ 的贡献，你会发现填 $S$ 中出现次数最少的字母最优。\n\n如何快速求出 $S$ 中出现次数最少的字母呢？我们知道有个函数叫做`min_element`（只是码量减少了，实际上还是遍历了一遍数组，时间复杂度不变），想要深入了解的请点 [Link1](https://blog.csdn.net/m0_74017151/article/details/137978014) & [Link2](https://zhuanlan.zhihu.com/p/435905136?utm_id=0) & [Link3（强烈推荐）](https://blog.csdn.net/weixin_51566349/article/details/127979598)。\n\n使用`min_element`的时间复杂度是 $\\Theta(26)$，遍历一遍字符串 $S$ 的时间复杂度是 $\\Theta(n)$，总时间复杂度是 $\\Theta(26n)$，显然不会超时。\n\n**此题有 $\\text{Special Judge}$，答案不唯一！**\n## Code\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nstring s;\nint c[26],n;\nint main(){\n\tcin>>n>>s;\n\tfor(int i=0;i<n;i++) c[s[i]-'a']++;//先统计每个字符出现的次数\n\tfor(int i=0;i<n;i++){\n        c[s[i]-'a']--;//先将s[i]字符的计数器减1，因为我们要找一个与s[i]不同的字符\n        cout<<(char)('a'+(min_element(c,c+26)-c));\n        /*\n        使用min_element(c,c+26)找到数组c中最小值的迭代器，这个最小值表示当前出现次数最少的字符\n        将这个迭代器转换为对应的字符（通过加上'a'并转换为字符），并输出\n        这个字符就是我们要选择的与s[i]不同的字符，因为它出现得最少，所以选择它最能增加不相似度\n        */\n        c[s[i]-'a']++;//将s[i]字符的计数器再加1，恢复原来的状态，以便处理下一个位置\n    }\n}\n```","tags":["字符串","贪心"],"categories":["题解"]},{"title":"题解：P11372 「CZOI-R2」加训","url":"/2026/02/16/题解：P11372 「CZOI-R2」加训/","content":"**原文：<https://www.luogu.com.cn/article/aji6d3z5> 点个赞吧！**\n\n---\n## 题意简述\n[题目传送门](https://www.luogu.com.cn/problem/P11372)。\n\n在 $k$ 维空间中，判断每个教练能看到多少个 OIer，要求视线不能被其他 OIer、障碍物或教练阻挡。\n## 思路\n~我们先把该读得先读入进来。~\n\n我们遍历所有教练，对于每个教练，执行以下步骤：\n* 我们遍历所有 OIer：\n  * 对于每个 OIer，检查它是否与当前教练在除了一个维度外其他维度都相同。\n  * 如果满足条件，则进一步检查这个不同的维度上，教练和 OIer 之间的线段是否被阻挡：\n    1. 首先，我们找到教练和 OIer 在 $k$ 维空间中唯一不同的那个维度，记为 $d$。\n    2.  假设教练在维度 $d$ 上的坐标为 $cd$，OIer 在维度 $d$ 上的坐标为 $od$。\n    3. 接下来，我们需要遍历所有的 OIer、障碍物和教练（除了当前正在考虑的教练和 OIer），我们检查遍历到的点是否在线段上：对于每个遍历到的点，我们检查它在维度 $d$ 上的坐标 $pd$ 是否位于 $cd$ 和 $od$ 之间，这可以通过简单的比较来实现：如果 $cd<od$，则检查 $cd<pd<od$；如果 $cd>od$，则检查 $od<pd<cd$。\n    4. 除了维度 $d$ 之外，我们还需要确保遍历到的点在其他所有维度上都与教练和 OIer 相同。\n这意味着，对于除了 $d$ 之外的每个维度 $i$，遍历到的点的坐标 $pi$ 应该等于教练的坐标 $ci$ 和 OIer 的坐标 $oi$。\n    5. 如果一个点同时满足上述两个条件（即在维度 $d$ 上位于线段上，且在其他维度上与教练和 OIer 相同），则它阻挡了教练看向 OIer 的视线。一旦找到这样的阻挡点，我们就可以停止对当前 OIer 的检查，并标记教练不能看到这个 OIer；如果没有找到阻挡点，我们继续遍历其他的 OIer、障碍物和教练，如果遍历完所有点后都没有找到阻挡点，则教练可以看到这个 OIer。\n    6. 如果教练和 OIer 之间的视线没有被阻挡，则增加计数器。\n* 输出计数器。\n## 后记\n排版可能有点乱，请大家耐心看。\n\n码字不易，打了好久，给个赞吧！","tags":["模拟"],"categories":["题解"]},{"title":"题解：P11376 [GESP202412 六级] 运送物资","url":"/2026/02/16/题解：P11376 [GESP202412 六级] 运送物资/","content":"**原文：<https://www.luogu.com.cn/article/sqk12qpn> 点个赞吧！**\n\n---\n## 题意简述\n有 $n$ 个运输站点和 $m$ 辆货车，货车需从站点出发向 A、B 两市运送物资，并返回站点。要求制定运输计划，最小化所有货车的总行驶路程。\n## 思路\n1. 首先，我们读取并存储所有运输站点的位置信息 $p_i$ 和可容纳的货车数量 $c_i$。\n2. 接着，读取每辆货车的运送需求，即需要向 A 市运送的次数 $a_i$ 和向 B 市运送的次数 $b_i$，并根据 $a_i$ 和 $b_i$ 的比较，将货车分为两类：\n   * 一类是去 A 市次数**不少于**去 B 市次数的货车集合 $F$。\n   * 另一类是去 B 市次数**多于**去 A 市次数的货车集合 $G$。\n\n   排序过程如下：\n   * 对运输站点按照位置 $p_i$ 进行升序排序。\n   * 对货车集合 $F$ 按照 $a_i-b_i$ 的降序排序。\n   * 对货车集合 $G$ 按照 $b_i-a_i$ 的降序排序。\n3. 使用贪心算法来分配货车到运输站点：\n   * 对于集合 $F$ 中的货车，从位置较近的运输站点开始分配。\n   * 对于集合 $G$ 中的货车，从位置较远的运输站点开始分配。\n   * 在分配过程中，确保每个运输站点的可容纳货车数量 $c_i$ 不会被超出。\n4. 根据货车的分配情况、运输站点的位置 $p_i$ 以及两市之间的距离 $x$，计算每辆货车的行驶距离，并累加得到总行驶距离 $ans$。对于集合 $F,G$ 中的货车，行驶距离都为 $2\\times(a_i \\times p_i+b_i\\times(x-p_i))$。\n5. 最后，输出计算得到的货车总行驶距离 $ans$。\n\n写的有点急，有问题请指出。求赞！\n\n感谢 @[HuangTingFu](/user/1014715) 指出错误。","tags":["贪心","排序"],"categories":["题解"]},{"title":"题解：B4071 [GESP202412 五级] 武器强化","url":"/2026/02/16/题解：B4071 [GESP202412 五级] 武器强化/","content":"**原文：<https://www.luogu.com.cn/article/jay65sxj> 点个赞吧！**\n\n---\n## 题意简述\n重新分配强化材料给武器，使第 $1$ 种武器材料数最多，且总转移成本最小。\n## 思路\n读取武器的种类数 $n$ 和强化材料的数量 $m$。对于每个强化材料，记录其对应的武器编号和成本，并统计每种武器的材料数量和成本列表。\n\n对每种武器的强化材料成本列表进行排序，以便后续能够高效地选择成本最低的材料。\n\n我们定义一个函数 $f$：该函数计算了在给定第 $1$ 种武器需要达到的强化材料数量 $x$ 时，将其他武器的材料转移到第 $1$ 种武器所需的最小成本。\n\n函数内部通过遍历每种非第 $1$ 种武器，计算需要转移的材料数量，并从该武器的成本列表中选择成本最低的材料进行转移。如果转移后第 $1$ 种武器的材料数量仍然不足 $x$，则从剩余的材料中选择成本最低的进行补充。\n\n我们遍历一个范围，从第 $1$ 种武器的初始材料数量到总材料数量。对于每个可能的 $x$ 值，调用函数 $f$ 计算转移成本，并更新全局最小成本。最终输出全局最小成本作为结果。","tags":["贪心","枚举"],"categories":["题解"]},{"title":"题解：P5686 [CSP-S2019 江西] 和积和","url":"/2026/02/16/题解：P5686 [CSP-S2019 江西] 和积和/","content":"**原文：<https://www.luogu.com.cn/article/3r0pec8u> 点个赞吧！由于 $\\LaTeX$ 公式有点炸了，所以在原文食用效果更佳！**\n\n---\n## 题意简述\n定义函数 $S(l,r)(1\\le l\\le r\\le n)$ 为：\n$$\\sum_{i=l}^ra_i \\times \\sum_{i=l}^rb_i$$\n请你求出下列式子的值：\n$$\\sum_{l=1}^n\\sum_{r=l}^nS(l,r)$$\n由于答案可能很大，你只需要给出答案模 $10^9+7$ 后的结果。\n## 思路\n首先尝试暴力，肯定会超时，所以我们要优化。\n\n两重循环显然可以用前缀和表示，我们可以用前缀和优化程序的时间复杂度：我们用 $A(i)$ 表示 $a_i$ 的前缀和，用 $B(i)$ 表示 $b_i$ 的前缀和。\n\n下面来推一波式子：\n$$\n\\begin{aligned}\nS(l,r)\n&=[A(r)-A(l-1)] \\times [B(r)-B(l-1)]\\\\\n  &=A(r) \\times B(r)+A(l-1) \\times B(l-1)-A(r) \\times B(l-1)-A(l-1) \\times B(r)\n\\end{aligned}\n$$\n所以：\n$$\n\\begin{aligned}\n\\sum_{l=1}^n\\sum_{r=l}^nS(l,r)\n&=\\sum_{l=1}^n\\sum_{r=l}^n[A(r) \\times B(r)+A(l-1) \\times B(l-1)-A(r) \\times B(l-1)-A(l-1) \\times B(r)]\\\\\n&=\\sum_{l=1}^n\\sum_{r=l}^n[A(r) \\times B(r)]+\\sum_{l=1}^n\\sum_{r=l}^n[A(l-1) \\times B(l-1)]-\\sum_{l=1}^n\\sum_{r=l}^n[A(r) \\times B(l-1)]-\\sum_{l=1}^n\\sum_{r=l}^n[A(l-1) \\times B(r)]\n\\end{aligned}\n$$\n得到上面的公式后，我们来分析每一项，并用 $ans$ 来记录答案：\n\n* 对于 $\\sum\\limits_{l=1}^n\\sum\\limits_{r=l}^nA(r) \\times B(r)$：我们用 $SAB(i)$ 表示 $A(r) \\times B(r)$ 的前缀和，所以 $ans+=\\sum\\limits_{l=1}^n[SAB(n)-SAB(l-1)]$。\n* 对于 $\\sum\\limits_{l=1}^n\\sum\\limits_{r=l}^nA(l-1) \\times B(l-1)$：$ans+=\\sum\\limits_{l=1}^n[(n-l+1) \\times A(l-1) \\times B(l-1)]$。\n* 对于 $\\sum\\limits_{l=1}^n\\sum\\limits_{r=l}^nA(r) \\times B(l-1)$：我们用 $SA(i)$ 表示 $A(r)$ 的前缀和，所以 $ans-=\\sum\\limits_{l=1}^n\\{B(l-1) \\times [SA(n)-SA(l-1)]\\}$。\n* 对于 $\\sum\\limits_{l=1}^n\\sum\\limits_{r=l}^nA(l-1) \\times B(r)$：我们用 $SB(i)$ 表示 $B(r)$ 的前缀和，所以 $ans-=\\sum\\limits_{l=1}^n\\{A(l-1) \\times [SB(n)-SB(l-1)]\\}$。\n\n总时间复杂度为 $\\Theta(n)$，可通过本题。\n## Code\n```cpp\n#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int maxn=5e5+5,mod=1e9+7;\nll n,a[maxn],b[maxn],A[maxn],B[maxn],SA[maxn],SB[maxn],SAB[maxn],ans;\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i],A[i]=(A[i-1]+a[i])%mod;\n\tfor(int i=1;i<=n;i++) cin>>b[i],B[i]=(B[i-1]+b[i])%mod;\n\tfor(int i=1;i<=n;i++) SA[i]=(SA[i-1]+A[i])%mod,SB[i]=(SB[i-1]+B[i])%mod,SAB[i]=(SAB[i-1]+(A[i]*B[i])%mod)%mod;\n\tfor(int i=1;i<=n;i++) ans=(ans+((SAB[n]-SAB[i-1])+mod)%mod)%mod;\n\tfor(int i=1;i<=n;i++) ans=(ans+(((n-i+1)*A[i-1])%mod*B[i-1])%mod)%mod;\n\tfor(int i=1;i<=n;i++) ans=((ans-(B[i-1]*((SA[n]-SA[i-1]+mod)%mod))%mod)+mod)%mod;\n\tfor(int i=1;i<=n;i++) ans=((ans-(A[i-1]*((SB[n]-SB[i-1]+mod)%mod))%mod)+mod)%mod;\n\tcout<<ans;\n}\n```\n注意：\n* 十年 OI 一场空，不开`long long`见祖宗！\n* 取模，有可能是负数的要先加`mod`再模`mod`。\n\n写了那么一大段 $\\LaTeX$，累死我了，可能有点问题，欢迎在评论区提出！点个赞吧！","tags":["数学","递推","前缀和","数论"],"categories":["题解"]},{"title":"题解：P1025 [NOIP2001 提高组] 数的划分","url":"/2026/02/16/题解：P1025 [NOIP2001 提高组] 数的划分/","content":"**原文：<https://www.luogu.com.cn/article/8t3rqvj5> 点个赞吧！**\n\n---\n## 思路\n这不是 DFS 板子题吗？实在没什么好讲的……~还是讲讲吧。~\n\n使用递归的方法来尝试所有可能的划分。每次递归处理一个部分，将整数加入当前部分，然后递归处理下一个部分。\n\n从最小的整数开始尝试，将其加入当前部分。继续递归处理，直到构建出 $k$ 个部分。\n\n当所有 $k$ 个部分都被填满时，检查这些部分的整数和是否等于 $n$。如果是，将这种划分计入结果。\n\n为了确保不同顺序的相同划分只被计数一次，规定每个部分中的整数必须不小于该部分之前的最小整数。这通过在递归调用中只尝试从当前整数开始及之后的整数来实现。\n\n剩下的在代码里讲吧。\n## Code\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n,k,ans;\nvoid dfs(int l,int p,int s){//l:当前份中最小的整数，p:当前已经划分的份数，s:当前所有份数的整数和\n\tif(p==k+1){//已经划分了 k 份\n\t\tif(s==n) ans++;//增加答案\n\t\treturn;//返回\n\t}\n\tfor(int i=l;s+i<=n;i++) dfs(i,p+1,s+i);//一定要从 l 开始，避免重复；s+i<=n 是为了确保不会超过总和 n；递归，作用分别为：成为下一份的最小可能值、进入下一份的划分、更新当前所有份的总和\n}\nint main(){\n\tcin>>n>>k,dfs(1,1,0),cout<<ans;\n}\n```","tags":["动态规划 DP","搜索","递推","剪枝"],"categories":["题解"]},{"title":"题解：P1022 [NOIP2000 普及组] 计算器的改良","url":"/2026/02/16/题解：P1022 [NOIP2000 普及组] 计算器的改良/","content":"**原文：<https://www.luogu.com.cn/article/0dwcdu96> 点个赞吧！**\n\n---\n## 思路\n这里先设定一下变量，之后在题解中会用到：\n* $c$：用于存储当前读取的字符。\n* $a$：用于存储未知数的名称（假设只有一个未知数）。\n* $f$：用于存储当前项的符号，初始值为 $1$（表示正号）。\n* $w$：用于指示当前是在等号的左边还是右边，初始值为 $1$（表示左边）。\n* $k$：用于累加未知数的系数，初始值为 $0$。\n* $s$：用于累加常数项，初始值为 $0$。\n* $t$：用于临时存储当前读取的数字，初始值为 $0$。\n* $r$：布尔值，用于标记是否正在读取一个数字。\n\n这里要用 `while(cin>>c)` 来进行读入。\n\n接下来处理每读入进来的字符：\n* 如果 $c$ 是`-`或`+`，这表示一个项的结束。根据 $w$ 和 $f$ 更新常数项 $s$，`s+=w*f*t`；重置 $f$ 为新的符号（`+`表示正，`-`表示负）；`t=0`，准备读取下一个数字；设置 `r=0`，表示当前不在读取数字。\n* 如果 $c$ 是`=`，表示等式两边的切换。更新 $s$ 以包括当前项，`s+=w*f*t`；切换 $w$ 到右边，`w=-1`；`f=1,t=0,r=0`。\n* 如果 $c$ 是小写字母（即未知数），这表示遇到了未知数。如果 $r=1$，说明之前读取了一个数字，应更新 $k$，`k+=w*f*t`；否则，直接更新 $k$，`k+=w*f`；记录未知数名称，`a=c`；`r=0`。\n* 如果 $c$ 是数字字符，更新当前数字 $t$，`t=t*10+(c-'0')`；`r=1`，表示正在读取数字。\n\n循环结束后，最后一项可能还未被处理（如果是常数项或未知数的最后一部分）。更新 $s$ 以包括最后一项，`s+=w*f*t`。\n\n计算未知数的值，`double ans=abs(double(-s*1.0/k))`。\n\n格式化输出，保留三位小数。\n\n有任何问题请指出！点个赞吧！","tags":["字符串","模拟","数学"],"categories":["题解"]},{"title":"题解：P9010 [USACO23JAN] Leaders B","url":"/2026/02/16/题解：P9010 [USACO23JAN] Leaders B/","content":"**原文：<https://www.luogu.com.cn/article/lfqjd3co> 点个赞吧！**\n\n---\n发现题解区里的解法咋都那么麻烦呢？这里介绍一种非常简单的方法，希望大家喜欢！\n## 题意简述\n这道题要求我们找出可能成为两种奶牛（根西岛 `G` 和荷斯坦 `H`）的“领导者”的所有可能的奶牛对。成为“领导者”的条件是：\n1. 其记录的名单上包含它的品种的所有奶牛。\n2. 其记录的名单上记录了另一品种奶牛的“领导者”。\n## 思路\n首先我们先找出第一种牛（假设为 `G` 品种）的最后一个牛的位置 $r$，再找出第二种牛（假设为 `H` 品种）的第一个牛的位置 $l$。\n\n找出领导者对的判断条件为 $i=1 \\land E_i \\ge r \\lor E_i \\ge l$，解释如下：\n* $i=1 \\land E_i \\ge r$：如果当前奶牛是第一头奶牛，并且它的名单结束位置 $E_i \\ge r$（即包含所有 `G` 品种奶牛），则它可以是一个领导者。这是因为如果第一头奶牛是 `G`，它需要知道所有 `G` 品种奶牛的信息。\n* $E_i \\ge l$：对于其他奶牛（不是第一头奶牛），如果它们的名单结束位置 $E_i \\ge l$（即包含第一个 `H` 品种奶牛的位置），则它们也可以是一个领导者。\n这是因为这些奶牛需要知道至少一个 `H` 品种奶牛的信息。\n\n两种条件满足一条即可。\n## Code\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=2e5+5;\nchar s[maxn];\nint n,l,r,e[maxn],ans;\nint main(){\n\tcin>>n>>(s+1);\n\tfor(int i=1;i<=n;i++) cin>>e[i];\n\tfor(int i=1;i<=n;i++){\n\t\tif(s[i]==s[1]) r=i;\n\t}\n\tfor(int i=2;i<=n;i++){\n\t\tif(s[i]!=s[1]){l=i;break;}\n\t}\n\tfor(int i=1;i<l;i++){\n\t\tif((i==1&&e[i]>=r)||e[i]>=l) ans++;\n\t}\n\tcout<<ans;\n}\n```\n**纯原创，想了好久，求赞！**","tags":["贪心"],"categories":["题解"]},{"title":"DeepSeek 本地部署指南","url":"/2026/02/16/DeepSeek 本地部署指南/","content":"**原文：<https://www.luogu.com.cn/article/i1kejuse> 点个赞吧！**\n\n---\n## 前言\n话说最近 DeepSeek 太火了，而且受到了攻击，所以[官网](https://www.deepseek.com/)卡得要命！\n\n所以我们可以在本地部署和运行 DeepSeek，实现 AI 对话的功能。\n## 安装\n在 [ollama 官网](https://ollama.com/) 上下载自己系统的版本。\n\n下载完后，重回 [ollama 官网](https://ollama.com/)，搜索 `deepseek-r1`，点第一个，然后选择适合自己电脑配置的选项，这里推荐 `7b` 的。\n![](https://cdn.luogu.com.cn/upload/image_hosting/c0t9xv6s.png)\n然后在终端或者 `powershell` 里输入指令：\n>```powershell\n>ollama run deepseek-r1:7b\n>```\n其中 `7b` 可替换为自己之前选择的选项。\n\n请**耐心**等进度条跑完，这可能会消耗~~几年~~**几小时**的时间。\n![](https://cdn.luogu.com.cn/upload/image_hosting/w1xjpp48.png)\n\n按下回车，就可以对话了！它使用的格式是 Markdown。\n![](https://cdn.luogu.com.cn/upload/image_hosting/426uwjdk.png)\n下面还有好多，就不贴了。\n\n为了方便对话，我们可以下载一个 Chatbox，[官网点这里](https://chatboxai.app/zh)。\n![](https://cdn.luogu.com.cn/upload/image_hosting/r8lzxdz5.png)\n下载完后打开，点击左下角的`设置`按钮，按照上述步骤修改，其余不变。\n![](https://cdn.luogu.com.cn/upload/image_hosting/tdbcgg7a.png)\n  现在就可以交流了！**如果不行的话请重启 Chatbox 再试试！**\n\n**求赞！求关注，必回关！**","categories":["科技·工程"]},{"title":"题解：P1071 [NOIP 2009 提高组] 潜伏者","url":"/2026/02/16/题解：P1071 [NOIP 2009 提高组] 潜伏者/","content":"**原文：<https://www.luogu.com.cn/article/jftnkm89> 点个赞吧！**\n\n---\n不知道为什么大家的做法都那么复杂，只有[一篇题解](/article/vjhqsomd)和我思路差不多。\n## 思路\n这就是个模拟题。我们设读入的三行字符串分别为 $a,b,c$。\n\n一看到题目，就知道可以用 `map` 解题。先设一个 `map<char,char>mp;`，用于整理“密码本”；再设一个 `map<char,bool>vis;`，用于记录哪个字符已经在“密码本”里了。\n\n首先遍历 $a$：如果 $vis_{b_i}=1 \\land b_i \\ne mp_{a_i}$，直接输出 `Failed` 并结束程序；否则，$mp_{a_i} \\gets b_i,vis_{b_i} \\gets 1$。\n\n然后遍历 $\\tt A \\sim Z$，如果 $vis_i=0$，输出 `Failed` 并结束程序。\n\n最后根据“密码本”翻译 $c$ 中的内容并输出。\n## Code\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nstring a,b,c;\nmap<char,char>mp;map<char,bool>vis;\nint main(){\n\tcin>>a>>b>>c;\n\tfor(int i=0;i<a.size();i++){\n\t\tif(vis[b[i]]&&b[i]!=mp[a[i]]){cout<<\"Failed\\n\";return 0;}\n\t\tmp[a[i]]=b[i],vis[b[i]]=1;\n\t}\n\tfor(char i='A';i<='Z';i++){\n\t\tif(!vis[i]){cout<<\"Failed\\n\";return 0;}\n\t}\n\tfor(int i=0;i<c.size();i++) cout<<mp[c[i]];\n}\n```","tags":["字符串","模拟"],"categories":["题解"]},{"title":"题解：P1044 [NOIP 2003 普及组] 栈","url":"/2026/02/16/题解：P1044 [NOIP 2003 普及组] 栈/","content":"**原文：<https://www.luogu.com.cn/article/v9r07ta2> 点个赞吧！**\n\n---\n## 思路\n假设我们用一个函数 $\\operatorname{C}(x,y)$ 表示：\n* $x$：当前还未入栈的数字个数。\n* $y$：当前栈中的数字个数。\n\n我们的目标是计算 $\\operatorname{C}(n,0)$，即从 $n$ 个数字开始，生成输出序列的方式。\n\n在任何状态下，我们有两种选择：\n* push 操作：如果还有数字可以入栈（即 $x>0$），我们可以将一个数字从输入序列中移入栈中。这会减少未入栈的数字个数 $x$，同时增加栈中的数字个数 $y$。因此，该操作对应于 $\\operatorname{C}(x-1,y+1)$。\n* pop 操作：如果栈中有数字可以出栈（即 $y>0$），我们可以将栈顶数字移出到输出序列中。这不会改变未入栈的数字个数 $x$，但会减少栈中的数字个数 $y$。因此，该操作对应于 $\\operatorname{C}(x,y-1)$。\n\n递归的边界条件是：当 $x=0 \\land y=n$ 时，表示所有数字已成功输出为一个序列，这算作一种有效方式，返回 $1$；其他不合法状态（如 $x<0 \\lor y>n$）返回 $0$。\n\n递归太慢，所以我们可以用 DP，转移方程是：\n$$f_{x,y}=f_{x-1,y+1}+f_{x,y-1}$$\n## Code\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint f[20][20],n;\nint main(){\n\tcin>>n;\n\tfor(int x=0;x<=n;x++){\n\t\tfor(int y=0;y<=n;y++){\n\t\t\tif(!x) f[x][y]=1;\n\t\t\telse if(!y) f[x][y]=f[x-1][y+1];\n\t\t\telse f[x][y]=f[x-1][y+1]+f[x][y-1];\n\t\t}\n\t}\n\tcout<<f[n][0];\n}\n```\n有问题请指出！\n\n感谢 @[NJYgocrazy](/user/1418820) 指出一个小错误。","tags":["数学","动态规划 DP","递推","Catalan 数"],"categories":["题解"]},{"title":"题解：P1087 [NOIP 2004 普及组] FBI 树","url":"/2026/02/16/题解：P1087 [NOIP 2004 普及组] FBI 树/","content":"**原文：<https://www.luogu.com.cn/article/o2ttrsv4> 点个赞吧！**\n\n---\n题目其实很简单，直接按照题意递归模拟就完事了。\n## 思路\n定义一个递归函数 $\\operatorname{solve}(l,r)$，其中 $l,r$ 表示当前子串的起始和结束索引。这个函数负责构造索引在 $[l,r]$ 里的子串对应的子树，并返回该子树的类型。\n\n函数里面是这样的：\n* 我们将子串分为左右两部分，用 $mid$ 来表示中间值。\n* 处理左右子树，分别为 $\\operatorname{solve}(l,mid),\\operatorname{solve}(mid+1,r)$。\n* 处理根节点：\n  * 遍历 $[l,r]$，统计 $0$ 和 $1$ 的个数，分别记作 $c_0,c_1$。\n  * 如果 $c_0>0 \\land c_1>0$，输出 `F`；否则如果 $c_0>0$，输出 `B`；否则，输出 `I`。\n\n主函数里面调用 $\\operatorname{solve}(0,2^n-1)$ 即可（这是下标从 $0$ 开始的代码，若下标从 $1$ 开始，则为 $\\operatorname{solve}(1,2^n)$）。\n## Code\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nstring s;int n;\nvoid solve(int l,int r){\n\tint mid=(l+r)/2,c0=0,c1=0;\n\tif(l!=r) solve(l,mid),solve(mid+1,r);\n\tfor(int i=l;i<=r;i++){\n\t\tif(s[i]=='0') c0++;\n\t\telse c1++;\n\t}\n\tif(c0&&c1) cout<<'F';\n\telse if(c0) cout<<'B';\n\telse cout<<'I';\n}\nint main(){\n\tcin>>n>>s,solve(0,pow(2,n)-1);\n}\n```","tags":["字符串","搜索","树形数据结构","递归"],"categories":["题解"]},{"title":"题解：P11996 我是黄色恐龙大将军","url":"/2026/02/16/题解：P11996 我是黄色恐龙大将军/","content":"**原文：<https://www.luogu.com.cn/article/25qthmcm> 点个赞吧！**\n\n---\n## 思路\n首先，我们需要明确题目要求的是**所有可能的** $a_n \\times b_n$ 的值的和，且**相同的值只计算一次**。因此，我们需要找到所有 $n$ 对应的 $a_n \\times b_n$，然后去重求和。\n* $a_n$ 是 $2^n$ 的最高非零位。\n* $b_n$ 是 $5^n$ 的最高非零位。\n\n我们计算 $a_n \\times b_n$ 的前几项：\n* $n=1$：$2^1=2,a_1=2,5^1=5,b_1=5,a_1 \\times b_1=10$。\n* $n=2$：$2^2=4,a_2=4,5^2=25,b_2=2,a_2 \\times b_2=8$。\n* $n=3$：$2^3=8,a_3=8,5^3=125,b_3=1,a_3 \\times b_3=8$。\n\n以此类推……\n\n我们发现从 $n=1 \\sim 30$ 的计算中，$a_n \\times b_n$ 的值有：\n$$10,8,8,6,9,6,7,6,5,9,8,8,8,6,9,6,7,6,5,9, 8,8,8,5,6,6,7,6,5,9$$\n去重后只剩：\n$$5,6,7,8,9,10$$\n将这些值相加：\n$$5+6+7+8+9+10=45$$\n答案就是 $45$。\n## 证明\n对于任意正整数 $k$，其最高非零位数字可以通过 $k$ 除以 $10^{\\lfloor\\log_{10}k\\rfloor}$ 并取整数部分得到。因此，$a_n=\\lfloor \\frac{2^n}{10^{\\lfloor n \\log_{10}2 \\rfloor}}\\rfloor,b_n=\\lfloor \\frac{5^n}{10^{\\lfloor n \\log_{10}5\\rfloor}}\\rfloor$。\n\n注意到 $\\log_{10}(2 \\times 5)=\\log_{10}10=1$，因此 $\\log_{10}2+\\log_{10}5=1$。设 $\\alpha=\\log_{10}2\\approx0.3010$，则 $\\log_{10}5=1-\\alpha\\approx0.6990$。\n\n$2^n$ 的十进制表示的位数是 $\\lfloor n \\alpha \\rfloor+1$；$5^n$ 的十进制表示的位数是 $\\lfloor n(1-\\alpha)\\rfloor+1$。$a_n$ 和 $b_n$ 的值主要由 $\\{n\\alpha\\}$ 和 $\\{n(1-\\alpha)\\}$ 决定，其中 $\\{x\\}$ 表示 $x$ 的小数部分。\n\n由于 $\\alpha$ 是无理数，序列 $\\{n\\alpha\\}$ 在区间 $[0,1)$ 上是均匀分布的。因此，$\\{n(1-\\alpha)\\}=1-\\{n\\alpha\\}$ 也是均匀分布的。\n\n$a_n$ 的值由 $2^n$ 的最高位决定，可以表示为 $\\lfloor 10^{\\{n\\alpha\\}}\\rfloor$；$b_n$ 的值由 $5^n$ 的最高位决定，可以表示为 $\\lfloor 10^{\\{n(1-\\alpha)\\}}\\rfloor=\\lfloor 10^{1-\\{n\\alpha\\}}\\rfloor$。因此，$a_n \\times b_n=\\lfloor 10^{\\{n\\alpha\\}}\\rfloor \\times \\lfloor 10^{1-\\{n\\alpha\\}}\\rfloor$。\n\n我们需要找到所有可能的 $\\lfloor 10^x \\rfloor \\times \\lfloor 10^{1-x} \\rfloor$ 的值，其中 $x \\in [0,1)$。\n* 对于 $x\\in[0,\\log_{10}2),\\lfloor 10^x \\rfloor=1,\\lfloor 10^{1-x}\\rfloor \\in \\{5,6,7,8,9,10\\}$：$1 \\times 5=5,1 \\times 6=6,1 \\times 7=7,1 \\times 8=8,1 \\times 9=9,1 \\times 10=10$。\n* 对于 $x\\in[\\log_{10}2,\\log_{10}3),\\lfloor 10^x \\rfloor=2,\\lfloor 10^{1-x}\\rfloor \\in \\{4,5\\}$：$2 \\times 4=8,2 \\times 5=10$。\n* 对于 $x\\in[\\log_{10}3,\\log_{10}4),\\lfloor 10^x \\rfloor=3,\\lfloor 10^{1-x}\\rfloor \\in \\{3,4\\}$：$3 \\times 3=9,3 \\times 4=12$（但 $12$ 不会出现，因为 $10^{1-x}$ 不会达到 $4$）。\n\n所以乘积不会超过 $10$。\n\n**有问题请指出！**","tags":["数学","枚举"],"categories":["题解"]},{"title":"题解：P12605 求和","url":"/2026/02/16/题解：P12605 求和/","content":"**原文：<https://www.luogu.com.cn/article/2jyyggc1> 点个赞吧！由于 $\\LaTeX$ 公式有点炸了，所以在原文食用效果更佳！**\n\n---\n## 思路\n把题意转化一下，我们需要计算 $s_1+s_2+\\cdots+s_n$ 和 $t_1+t_2+\\cdots+t_n$ 的表达式。\n\n首先计算前缀和的总和：\n$$S=\\sum_{k=1}^ns_k=\\sum_{k=1}^n\\sum_{i=1}^ka_i=\\sum_{i=1}^na_i \\cdot (n-i+1)$$\n这是因为每个 $a_i$ 在 $s_i,s_{i+1},\\cdots,s_n$ 中出现了 $(n-i+1)$ 次。\n\n我们用同样的方法计算后缀和的总和：\n$$T=\\sum_{k=1}^nt_k=\\sum_{k=1}^n\\sum_{i=k}^na_i=\\sum_{i=1}^na_i \\cdot i$$\n这是因为每个 $a_i$ 在 $t_1,t_2,\\cdots,t_i$ 中出现了 $i$ 次。\n\n因此，等式 $S=T$ 可表示为：\n$$\\begin{aligned}\n\\sum_{i=1}^na_i \\cdot (n-i+1)&=\\sum_{i=1}^na_i \\cdot i\\\\\n\\sum_{i=1}^na_i \\cdot (n-i+1)-\\sum_{i=1}^na_i \\cdot i&=0\\\\\n\\sum_{i=1}^na_i \\cdot (n-i+1-i)&=0\\\\\n\\sum_{i=1}^na_i \\cdot (n-2i+1)&=0\n\\end{aligned}\n$$\n记 $c_i=n-2i+1$，则条件为：\n$$\\sum_{i=1}^na_i \\cdot c_i=0$$\n我们设初始偏差为 $D$，计算初始的 $D=\\sum\\limits_{i=1}^na_i \\cdot c_i$\n我们每次可以选择 $i$ 和 $j$，$D$ 的变化为 $c_i-c_j=2(j-i)$。因此，每次操作可以调整 $D$ 的值为 $\\pm2(j-i)$。为了最小化操作次数，应尽可能选择最大的 $|j-i|$，即 $i=1,j=n$，此时 $|\\Delta|=2(n-1)$。\n\n* 如果 $D$ 是奇数，显然无法通过偶数次调整得到 $0$，直接返回 $-1$。\n* 如果 $D$ 是偶数，最小操作次数为 $\\lceil\\frac{|D|}{2(n-1)}\\rceil$。\n## Code\n```cpp\n#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int maxn=1e6+5;\nll n,a[maxn],d;\nint main(){\n\tcin>>n;\n\tfor(ll i=1;i<=n;i++) cin>>a[i];\n\tif(n==1){cout<<0;return 0;}\n\tfor(ll i=1;i<=n;i++){\n\t\tll c=n-i*2+1;\n\t\td+=a[i]*c;\n\t}\n\tif(d%2) cout<<-1;\n\telse cout<<(abs(d)+2*(n-1)-1)/(2*(n-1));\n}\n```\n注意：\n* 要开 `long long`。\n* 要特判 $n=1$ 的情况，因为如果这样的话 $n-1=0$，会导致除零错误，会 `RE`。\n* 如果使用 `ceil` 向上取整的话会出现浮点误差，所以推荐使用代码中的写法进行向上取整。","tags":["贪心","前缀和"],"categories":["题解"]},{"title":"题解：P1431 找出伪币","url":"/2026/02/16/题解：P1431 找出伪币/","content":"**原文：<https://www.luogu.com.cn/article/0z1js5qr> 点个赞吧！**\n\n---\n## 思路\n每次 $p$ 就只有两种状态：\n* 当 $p \\ne 0$ 时。每次称重有 $3$ 种可能结果（左重、右重、平衡），可产生 $\\log_3 3=1$ 个三进制位的信息量，区分 $n$ 个不同情况需要 $\\lceil \\log_3 n \\rceil$ 次称重。所以最少称量次数 $m$ 满足 $3^m \\ge n$，即 $m = \\lceil \\log_3 n \\rceil$。\n* 当 $p=0$ 时。这个时候我们不仅需要定位伪币，还需确定其轻重，每个硬币有 $2$ 种可能性（可能轻或重），总可能性为 $2n$ 种，最少需要区分 $2n+3$ 种情况。证明的话可以去看其他题解，这里不再赘述。所以最少称量次数 $m$ 满足 $3^m \\ge 2n + 3$，即 $m=\\lceil \\log_3 (2n+3) \\rceil$。\n\n然而，这道题目的关键点在于高精度，普通高精被卡，只能用压位高精……我写的是 $18$ 位压位存储，时间复杂度 $\\Theta(\\frac{Tk^2}{18^2})=\\Theta(\\frac{Tk^2}{324})$。\n## Code\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst long long BASE=1e18;//定义大数的基数为 1e18（每位存储 18 位十进制数）\nconst int BASE_DIGITS=18;\nvector<long long>sto(string s){//字符串转大数（按 18 位分割存储）\n\tvector<long long>res;\n\tfor(int i=s.size();i>0;i-=BASE_DIGITS){//从字符串末尾开始，每次处理 18 位\n\t\tint start=max(0,i-BASE_DIGITS);//计算当前段的起始位置\n\t\tstring part=s.substr(start,i-start);//截取 18 位字符串\n\t\tres.push_back(stoll(part));//转换为 long long 并存入 vector\n\t}\n\treturn res;\n}\nvector<long long>mul(vector<long long>a,int b){//大数乘法\n\tvector<long long>res;\n\tlong long c=0;//进位\n\tfor(long long x:a){//逐位相乘\n\t\tlong long p=x*b+c;//当前位乘积+进位\n\t\tres.push_back(p%BASE),c=p/BASE;//取模得到当前位并计算新的进位\n\t}\n\twhile(c) res.push_back(c%BASE),c/=BASE;//处理剩余进位\n\treturn res;\n}\nvector<long long>add(vector<long long> a,vector<long long> b){//大数加法\n\tvector<long long>res;\n\tlong long c=0;//进位\n\tfor(int i=0;i<max(a.size(),b.size())||c;i++){//逐位相加（处理不等长情况）\n\t\tlong long sum=c;\n\t\tif(i<a.size()) sum+=a[i];\n\t\tif(i<b.size()) sum+=b[i];\n\t\tres.push_back(sum%BASE),c=sum/BASE;//取模得到当前位并计算新的进位\n\t}\n\treturn res;\n}\nbool cmp(vector<long long>a,vector<long long>b){//大数比较\n\tif(a.size()!=b.size()) return a.size()>b.size();//先比较位数\n\tfor(int i=a.size()-1;i>=0;i--){//从高位到低位逐位比较\n\t\tif(a[i]!=b[i]) return a[i]>b[i];\n\t}\n\treturn true;\n}\nint solve(string s,bool f){\n\tvector<long long>t=sto(s);\n\tif(f){//如果需要特殊计算\n\t\tt=mul(t,2);\n\t\tvector<long long>k={3};\n\t\tt=add(t,k);\n\t}\n\tvector<long long>a={1};\n\tint m=0;//幂次计数\n\twhile(!cmp(a,t)) a=mul(a,3),m++;//不断乘 3 直到大于等于目标值\n\treturn m;\n}\nint main(){\n\tios::sync_with_stdio(0),cin.tie(0);\n\tint T;cin>>T;\n\twhile(T--){\n\t\tint k,p;string n;cin>>k>>p>>n;\n\t\tbool f=(p==0);//特判\n\t\tcout<<solve(n,f)<<'\\n';\n\t}\n}\n```\n有问题请指出！","tags":["数学","高精度"],"categories":["题解"]},{"title":"题解：P6842 [BalkanOI 2009] Strip","url":"/2026/02/16/题解：P6842 [BalkanOI 2009] Strip/","content":"**原文：<https://www.luogu.com.cn/article/fgtc7gov> 点个赞吧！**\n\n---\n感觉其他题解有点难懂，这里发一篇通俗的。\n## 思路\n我们维护两个变量 $l,r$ 分别表示当前条带的左右端点，再维护一个数组 $t$ 表示**翻折（即“对称轴”）的实际位置**。\n\n因为往右边翻可以保证 $l \\ge 0,r \\ge 0$，所以我们**统一往右边翻**。\n\n我们考虑一个问题：对于对称轴 $s$ 折叠后，原来位置 $x$ 的点现在在哪里？\n* 如果 $x \\ge s$：还在原来的位置。\n* 如果 $x<s$：被翻到右边，新位置为 $2s-x$。\n\n我们设每次读进来的“对称轴”为 $a$。但由于经过了翻折，$a$ 对应的是原条带的下标，而我们要的是当前的实际下标。所以我们要求出，经过前 $i-1$ 次折叠后，原始位置 $a$ 在当前条带中的实际位置是多少？\n\n设 $f(x)$ 表示原始位置 $x$ 经过所有折叠后的实际位置。对于第 $j$ 次折叠在位置 $t_j$：\n* 如果 $f(x) \\ge t_j$：保持不变。\n* 如果 $f(x)<t_j$：那么 $f(x)=2 \\times t_j-f(x)$。\n\n由此我们可以得到 $a$ 每次操作得到的实际位置是 $a=\\max(a,2 \\times t_j-a)$，需要进行 $i-1$ 次翻折操作才能求出 $a$ 的实际位置。\n\n我们知道了“对称轴”的位置，就可以求出 $l,r$ 的值啦！$r$ 的位置变成了 $r$ 和 $l$ 的对称点的最大值（因为翻折后 $r$ 有可能会超过原来右端点的位置，也有可能不超过，所以取最大值），$l$ 的位置变成了 $a$ 的位置，我们根据上面的公式可得出 $r=\\max(r,2a-l),l=a$。\n\n**注意不能交换操作顺序，必须先更新 $r$ 再更新 $l$，因为 $r$ 的计算需要旧的 $l$ 值。否则只有 $28$ 分……。**\n\n由于题目中的长度定义为**两端点之间的距离**，而我们的 $l,r$ 是条带的左右端点位置，因此输出 $r-l$ 即可得到正确的条带长度，不要输出 $r-l+1$。\n\n代码和楼上楼下差不多，就不贴了。","tags":["模拟","数学"],"categories":["题解"]},{"title":"CSP-J/S 2025 游记","url":"/2026/02/16/CSP-JS 2025 游记/","content":"**原文：<https://www.luogu.com.cn/article/4mazvyjo> 点个赞吧！**\n\n---\n## 前言\n[前景摘要](https://www.luogu.com.cn/article/dc2jdedt)。\n\n这是我第一次 CSP 进复赛，必须记录一下！\n## 初赛\n### Day#0\n上初一了，晚上写了会儿作业，没时间开电脑。\n### Day#1\n#### 赛前\n早上 4:30 就行了，开电脑，复习。\n\n抽了一下运势，还是 `中吉`。\n\n早上出发去镇海蛟川书院，那里人好多啊，感觉再晚一点就来不及了。\n#### CSP-J\n拿到试卷赶紧翻了一下，发现题目还可以，长输了一口气。\n\n然后就开始疯狂地写试卷，刷刷刷奋笔疾书，废了好几页草稿纸，有一题我直接模拟 $O(n!)$，此间一切顺利。\n#### 中午\n出考场后，我发现我被第一题坑了，题目说的是**无符号**……\n\n估分，发现各个平台估出来的分都不一样（差距还挺大），就躺平了。在肯德基吃了一个汉堡，背了一会 whk，就又出发了。\n#### CSP-S\n已经做足了心理准备，该做的做，该猜的猜，胡乱写完了。\n\n当我看到代码中有一个 `You have no egg.` 的时候，我差点喷出来。\n#### 赛后\nJ 组估分 $81 \\pm 5$，S 组估分 $60 \\pm 10$。结果最后 J 组得了 $79$，S 组得了 $66$，都进了复赛。唯一遗憾的是，S 组一等线为 $66.5$，就差半分就可以一等了！/kel\n## 复赛\n### Day#0\n下午提早从学校出来，去赶六点钟的动车，可惜是无座票，只能一边站着一边背道法了（腿真的好累啊 awa）。到达杭州东后，上出租车去酒店，我爸和司机聊了一路。来到酒店，坐了一会儿 whk 作业，复习了一会 CSP 就睡了。\n### Day#1\n#### 赛前\n一大早起来吃早餐，然后就出发了，一会儿就抵达杭州师范大学下沙校区了。\n#### CSP-J\n开题！发现题目好简单呀。\n\nT1&T2 直接秒了。\n\nT3 没有把握，只会写一个前缀异或和+错误贪心思路，感觉肯定会 WA。\n\nT4 只会写暴力，但是在赛场上忘记 `next_permutation` 怎么用了，就临时写了个 dfs，顺便写了个对拍，应该没问题。\n#### 中午\n我爸去保安那要了一个二维码，进了食堂，感觉饭菜还可以。但是我没时间估分了。\n#### CSP-S\n下午 T1 想出了贪心思路但发现思路假了，直接崩溃，然后调暴力，感觉只能拿 $25$ 分。\n\nT2 感觉有点复杂，懒得写（其实是因为 T1 已经调了 2h 了），直接水了一个乱搞代码，预估分数 $0$。\n\nT3 看不懂在干什么，直接总司令，预估分数 $0$。\n\nT4 看懂了但是不知道怎么写，就水了个特殊性质。\n#### 赛后\nJ 组估分 $100+100+30+40=270$，但实际分数为 $100+100+20+40=260$，真的不知道 T3 为什么会挂了 $10$ 分；S 组估分 $25+0+0+0=25$，但实际分数为 $35+0+0+4=39$，有点神奇。没能拿到 NOIP 资格……\n## 后记\n这次不知道能不能拿到一等+五级钩（大概率没了），明年再战！CSP-2026 RP++！","tags":["2025"],"categories":["生活·游记"]},{"title":"必看","url":"/2026/02/16/必看/","content":"这里是 [\\_\\_CJY__](https://www.luogu.com.cn/user/1086453) 的个人博客，在这里你可以看到：\n* 精美的学习笔记\n* 逻辑清晰的题解${}^{\\tt 1}$\n* 惊心动魄的游记\n\n${}^{\\tt 1}$：特别的，这里只记录在[洛谷](https://www.luogu.com.cn/)上深受好评的**优质**题解，如果你想看到我的所有文章，请[截这里](https://www.luogu.com.cn/user/1086453/article)！\n\n**另外，这是[我的私信](https://www.luogu.com.cn/chat?uid=1086453)，欢迎交流、勘误，也希望你们在我的洛谷专栏上能多多点赞！**\n\n***祝你看得开心！***","categories":["重要杂文"]},{"title":"题解：P14954 520","url":"/2026/02/15/题解：P14954 520/","content":"**原文：<https://www.luogu.com.cn/article/cvw7gi8f> 点个赞吧！**\n\n---\n感觉其他题解讲的都不太清楚，我来讲讲，可能有些重复，请见谅！\n## 思路\n1. 首先先把已有的 $520$ 找出来，并将它们标记为空。\n2. 再把缺一个数字的（即 $52,20,50$）算上。\n3. 按照“优先使用当前最不稀缺的插入字符”的贪心策略用单个字符加两个插入字符形成 $520$。\n4. 剩下的插入字符直接组成完整的 $520$，加上。\n## Code\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint T,n,a,b,c,res,s1,s2,s3;\nint main(){\n\tcin>>T;\n\twhile(T--){\n\t\tcin>>n>>a>>b>>c,res=s1=s2=s3=0;\n\t\tstring s;cin>>s;\n\t\tfor(int i=0;i<n-2;i++){//第一步\n\t\t\tif(s.substr(i,3)==\"520\") res++,s[i]=s[i+1]=s[i+2]=' ';\n\t\t}\n\t\tfor(int i=0;i<n-1;i++){//第二步\n\t\t\tif(s.substr(i,2)==\"52\"&&c) res++,c--,s[i]=s[i+1]=' ';\n\t\t\telse if(s.substr(i,2)==\"20\"&&a) res++,a--,s[i]=s[i+1]=' ';\n\t\t\telse if(s.substr(i,2)==\"50\"&&b) res++,b--,s[i]=s[i+1]=' ';\n\t\t}\n\t\tfor(int i=0;i<n;i++){//统计三种数字的个数\n\t\t\tif(s[i]=='5') s1++;\n\t\t\telse if(s[i]=='2') s2++;\n\t\t\telse if(s[i]=='0') s3++;//注意这里不能用 else，因为 s[i] 有可能为空格\n\t\t}\n\t\twhile(s1||s2||s3){//第三步\n\t\t\tif(a>=c&&b>=c&&s3&&a&&b) res++,s3--,a--,b--;//如果 a 和 b 都 >= c，且有 0 可用，则消耗 a 和 b\n\t\t\telse if(a>=b&&c>=b&&s2&&a&&c) res++,s2--,a--,c--;//同上\n\t\t\telse if(b>=a&&c>=a&&s1&&b&&c) res++,s1--,b--,c--;//同上\n\t\t\telse break;\n\t\t}\n\t\tres+=min({a,b,c}),cout<<res<<'\\n';//第四步\n\t}\n}\n```","tags":["贪心"],"categories":["题解"]}]